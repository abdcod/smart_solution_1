# Задача про боевые потенциалы

## Условия

Андрей очень любит играть в одну никому не известную игру. В процессе игры герой Андрея выполняет задания и получает взамен определенные вещи. Каждая вещь обладает боевым потенциалом (БП), БП - это некоторое целое число X. Если X > 0, то вещь нужна для наступления, если X < 0, то вещь нужна для обороны, если X = 0 то вещь нужна для колдовства.

Боевой потенциал героя считается как произведение боевых потенциалов всех вещей, которыми он обладает.

Андрей уже долго играет и накопил N вещей. К Андрею обратился его друг Василий с просьбой передать ему какую-нибудь одну вещь для того чтобы спасти героя Василия от гибели. Андрей хочет помочь Василию, однако так же хочет, чтобы его собственный герой обладал максимальным боевым потенциалом после того как отдаст одну из накопленных вещей.

Напишите программу, котрая определит какую вещь следует передать Василию.

### Формат ввода

На первой строке входных данных находится одно число N - количество предметов, которыми обладает герой Андрея.
На второй строке находится N целых чисел A<sub>i</sub>, где A<sub>i</sub> - боевой потенциал i-ого предмета.

### Ограничения

1 ≤ N ≤ $10^5$   
$-10^9$ ≤ A<sub>i</sub> ≤ $10^9$

### Формат вывода

Выведите одно число -  боевой потенциал предмета, который Андрей должен передать Василию, так чтобы герой Андрея обладал максимальным боевым потенциалом среди всех возможных после передачи. Решений может быть несколько - тогда подойдет любое.

#### Пример 1

Ввод              | Вывод
----------------- | -------------
6                 | 1
1 2 3 4 5 6       | 

#### Пример 2

Ввод              | Вывод
----------------- | -------------
6                 | -6
-1 -2 -3 -4 -5 -6 | 

#### Пример 3

Ввод              | Вывод
----------------- | -------------
5                 | -1
-1 -2 -3 -4 -5    | 



#### Пример 4

Ввод              | Вывод
----------------- | -------------
4                 | 0
0 1 3 4           | 


#### Пример 5

Ввод              | Вывод
----------------- | -------------
5                 | -5
0 1 3 4 -5        | 


## Решение:

Парсим массив. Проходимся по нему. И в процессе вычисляем некоторые данные:

1) Нужен счётчик, который будет считать сколько всего было отрицательных чисел.
2) Нужна переменная, в которую будет перезаписываться наименьше из всех отрицательных чисел.
3) Нужна переменная, которая ответит на вопрос, был ли среди массива ноль.
4) Нужна переменная, в которую будет записываться наибольшее из отрицательных (то есть ближе к нулю...) чисел.
5) Нужна переменная, в которую будет записываться наименьшее из неотрицательных чисел.
  
После этого с помощью полученной информации реализуем следующее:

1. Если отрицательных чисел четное количество (в том числе их количество -
ноль), и при этом есть неотрицательные числа (в том числе возможно нолик) -
отдаем наименьшее из неотрицательных.
2. Если отрицательных четное количество(в том числе их количество - ноль), и при этом неотрицательных нет, отдаем
наименьшее из отрицательных.
3. Если отрицательных нечетное количество, и при этом есть ноль, отдавать любое
неотрицательное.
4. Если отрицательных нечетное количество, и при этом нет ноля, но есть другие
неотрицательные, тогда отдавать наибольшее из отрицательных (ближайшее к
нулю).
5. Если отрицательных нечётное количество, и при этом больше нет чисел, отдавать
наибольшее из отрицательных (ближайшее к нулю).

```
#include <stdio.h>

int main() {
  int count;
  int scanf_counter = 0;
  scanf("%d", &count);
  int array[count];
  while (scanf_counter < count) {
    scanf("%d", &array[scanf_counter]);
    scanf_counter++;
  }
  // на этом моменте мы спарсили массив

  int counter_of_negative = 0;  // счётчик отрицательных чисел
  int counter_of_positive = 0;  // счётчик неотрицательных чисел
  int low_negative_buf = 1;  // наименьшее отрицательное число (наиболее близкое
                             // к минус бесконечности)
  int have_null = 0;         // есть ли ноль в массиве
  int high_negative_buf =
      1;  // наибольшее отрицательно число (наиболее близкое к нулю)
  int low_nonegative_buf = -1;  // наименьшее неотрицательное число
  int i = 0;                    // счётчик ячейки массива
  int output = 666;  // вывод

  while (i < count) {  // побежали по массиву анализировать его
    if (array[i] < 0) {  // если элемент массива - отрицательное число
      counter_of_negative++;
      if (array[i] < low_negative_buf) {
        low_negative_buf = array[i];
      }
      if (high_negative_buf == 1) {
        high_negative_buf = array[i];
      }
      if (array[i] > high_negative_buf) {
        high_negative_buf = array[i];
      }
    } else if (array[i] == 0) {  // если элемент массива - ноль
      have_null++;
      counter_of_positive++;
      low_nonegative_buf = array[i];
    } else {  // если элемент массива - положительное число
      counter_of_positive++;
      if (low_nonegative_buf == -1) {
        low_nonegative_buf = array[i];
      }
      if ((low_nonegative_buf != -1) && (array[i] < low_nonegative_buf)) {
        low_nonegative_buf = array[i];
      }
    }
    i++;
  }

  if (counter_of_negative % 2 == 0 && counter_of_positive != 0) {
    output = low_nonegative_buf;
  }
  if (counter_of_negative % 2 == 0 && counter_of_positive == 0) {
    output = low_negative_buf;
  }
  if (counter_of_negative % 2 != 0 && have_null > 0) {
    output = high_negative_buf;
  }
  if (counter_of_negative % 2 != 0 && have_null == 0 &&
      counter_of_positive > 0) {
    output = high_negative_buf;
  }
  if (counter_of_negative % 2 != 0 && counter_of_positive == 0) {
    output = high_negative_buf;
  }
  printf("%d\n", output);
}
```
